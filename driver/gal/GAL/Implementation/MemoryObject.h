/**************************************************************************
 *
 */

#ifndef MEMORYOBJECT
    #define MEMORYOBJECT

#include <map>
#include <vector>
#include "GALResource.h"

namespace libGAL
{

/**
 * Possible memory object states
 */
enum MemoryObjectState
{
    MOS_ReAlloc,        ///< Indicates that the object region must be fully reallocated (previous contents can be discarded)
    MOS_NotSync,        ///< Indicates that the object region requires update
    MOS_Sync,           ///< The object region does not required updating CPU & GPU memory are synchronized
    MOS_Blit,           ///< GPU memory is updated (due to a blit op), CPU memory not. The only transition accepted is to MOS_REALLOC.
    MOS_RenderBuffer,   ///< Objects stores data generated by the GPU.
    MOS_NotFound,       ///< The region queried does not exist
};



/**
 * MemoryObject adds support for CPU/GPU memory synchronization and priorization
 *
 * All resource objects implementations (textures, buffers, etc) must inherit from this base
 * abstract class
 *
 * This class implements the state concept of resources, each resource has a number of states
 * equeals to its number of memory regions
 *
 * @author Carlos González (cgonzale@ac.upc.edu)
 * @date 02/19/2007
 */
class MemoryObject
{

friend class MemoryObjectAllocator;

public:

    /**
     * Defines the preferred memory locations for memory objects
     */
    enum MemoryType
    {
        MT_SystemMemory, ///< Data object will be stored in system user memory
        MT_LocalMemory, ///< Data will be allocated in local GPU memory
    };

    /**
     * COnstructor automatically called by each subclass
     */
    MemoryObject();

    std::vector<gal_uint> getDefinedRegions() const;


    /**
     * Gets the memory object state of a memory object region
     *
     * @param region the region to query
     *
     * @note If the region does not exist, MOS_NotFound is returned
     */
    MemoryObjectState getState(gal_uint region) const;

    /**
     * This method retrives a value indicating the number of reallocations posted till now
     *
     * This method can be used to warranty that a MemoryObject REGION has not been reallocated
     * between a range of time
     *
     * @code
     *
     *    MemoryObject* mo = ...;
     *
     *    // At certain time
     *    gal_uint old = m->trackRealloc();
     *
     *    // Later
     *
     *    if ( m->trackRealloc() == old ) {
     *       // Can execute code that assumes that memory object has the same @ in GPU
     *    }
     * 
     */
    gal_uint trackRealloc(gal_uint region) const;


    /**
     * Set the lock state of a given region
	 *
     */
	void lock(gal_uint region, gal_bool lock);

    /**
     * This method retrives a value indicating if the memory region is previouly used in the previous frame
	 *
	 * @returns if the region is locked
     */
	gal_bool isLocked(gal_uint region) const;

    /**
     * Set the preload data state of a given region
	 *
     */
	void preload(gal_uint region, gal_bool preload);

    /**
     * This method retrives a value indicating if the memory region is to be preload into GPU memory (zero simulation cycles).
	 *
	 * @returns if the region contain preload data.
     */
	gal_bool isPreload(gal_uint region) const;

    /**
     * This method retries a value indicating the number of reallocations posted till now
     *
     * This method differs from the REGION version since it tracks all region reallocations
     * in the same variable. It provides a method to verify if any REGION of the resource
     * has been reallocated
     *
     * @returns Sum of reallocations of each resource region
     */
    gal_uint trackRealloc() const;

    /**
     * Sets which memory is preferred to allocate this object
     */
    void setPreferredMemory(MemoryType mem);

    /**
     * Gets which is the preferred memory to allocate this memory object
     */
    MemoryType getPreferredMemory() const;

    /**
     * Gets a pointer to the binary data of a memory object region
     *
     * The memory layout is the required GPU memory layout
     *
     * @param region The memory region selected
     * @retval memorySizeInBytes the size of the memory region selected (in bytes)
     */
    virtual const gal_ubyte* memoryData(gal_uint region, gal_uint& memorySizeInBytes) const = 0;

    /**
     * Obtains the memory object region range that requires updating based on
     * The eg
     *
     * @param region Region queried
     * @retval startByte First byte retrived with memoryData() method that requires updating
     * @retval lastByte Last byte retrieved with memoryData() method that requires updating
     */
    void getUpdateRange(gal_uint region, gal_uint& startByte, gal_uint& lastByte);

    /**
     * Each subclass should define its own string type
     */
    virtual const gal_char* stringType() const;

    void postBlit(gal_uint region);

    void postRenderBuffer(gal_uint region);

protected:

    /**********************
     * Post state methods *
     **********************/
    void postUpdate(gal_uint region, gal_uint startByte, gal_uint lastByte);
    void postUpdateAll();
    void postReallocate(gal_uint region);
    void postReallocateAll();
    
    void postBlitAll();
    
    void postRenderBufferAll();

    // Must be called by subclasses to init region information, when a region must be defined
    void defineRegion(gal_uint region);
    void undefineRegion(gal_uint region);

private:

    // Can only be called by MemoryObjectAllocator
    void changeState(gal_uint region, MemoryObjectState newState);
    
    MemoryType _preferredMemory;

    struct MemoryObjectRegion
    {
        MemoryObjectState state;
        gal_uint firstByteToUpdate;
        gal_uint lastByteToUpdate;
        gal_uint reallocs;
		gal_uint locked;
		gal_bool preload;
    };

    std::map<gal_uint, MemoryObjectRegion> mor;

    gal_uint _globalReallocs;

    void _postUpdate(gal_uint moID, MemoryObjectRegion& moRegion, gal_uint startByte, gal_uint lastByte);


};

}


#endif // MEMORYOBJECT

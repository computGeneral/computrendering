/**************************************************************************
 *
 */



#include "TraceDriverMeta.h"
#include <cstdio>
#include <iostream>
#include <cstring>

using namespace cg1gpu;
using namespace std;

TraceDriverMeta::TraceDriverMeta(gzifstream *ProfilingFile, U32 startFrame_, U32 traceFirstFrame_) :
    startFrame(startFrame_), currentFrame(0), traceFirstFrame(traceFirstFrame_),
    startTransaction(0),
    fragmentProgramPC(0), fragmentProgramAddress(0), fragmentProgramSize(0),
    vertexProgramPC(0), vertexProgramAddress(0), vertexProgramSize(0),
    lastProgramUpload(NULL), agpTransCount(0), shaderProgramLoadPhase(0)
{
    traceTyp = TraceTypCgp;
    MetaTraceFile = ProfilingFile;

    //  Clear the shader program data caches
    memset(fragProgramCache, 0, sizeof(fragProgramCache));
    memset(vertProgramCache, 0, sizeof(vertProgramCache));    

    //  Check if the driver must skip frames.
    if (startFrame != currentFrame)
        currentPhase = TP_PREINIT;
    else
        currentPhase = TP_SIMULATION;
        
}

int TraceDriverMeta::startTrace()
{
    // do not do anything :-)
    return 0; // return state of TraceDriver object ( 0 means ready )
}


// new version to allow hotStart with identical memory footprint
cgoMetaStream* TraceDriverMeta::nxtMetaStream()
{
    cgoMetaStream* metaStream = NULL;
    //  Check for the MetaStream trace file
    if (MetaTraceFile != NULL)
    {
        //  Keep reading the MetaStream trace file until an MetaStream can be sent to the simulator
        while (!MetaTraceFile->eof() && metaStream == NULL)
        {
            //  Check if the MetaStreams are being generated by the trace reader or
            //  read from the MetaStream trace file.
            if ((currentPhase == TP_PREINIT) || (currentPhase == TP_SIMULATION))
            {
                //  Read the next MetaStream from the input MetaStream trace file.
                metaStream = new cgoMetaStream(MetaTraceFile);
                
                //  Check for end of file.
                if (MetaTraceFile->eof())
                {
                    delete metaStream;
                    metaStream = NULL;
                    break;
                }
                    
                //metaStream->dump();

                //  Update agp transaction counter.
                agpTransCount++;
            }
            
            //  Check in which processing phase is the MetaStream Trace Driver.
            switch(currentPhase)
            {
            
                case TP_PREINIT:
            
                    //  Check if skipping commands has to end.
                    if ((startTransaction > 0) && (agpTransCount == startTransaction))
                    {
                        //  Start loading the cached shader programs.
                        currentPhase = TP_LOAD_SHADERS;
                    }
                            
                    //  Determine what to do based on the kind of MetaStream.
                    switch(metaStream->GetMetaStreamType())
                    {
                        case META_STREAM_WRITE:
                        
                            //  Convert all the upload operations into META_STREAM_PRELOAD transactions.
                            metaStream->forcePreload();
                            
                            //  Check if this upload operation may be a shader program upload.
                            if (metaStream->getSize() <= (SHADERINSTRUCTIONSIZE * MAXSHADERINSTRUCTIONS))
                            {
                                lastProgramUpload = new ProgramUpload(metaStream->getAddress(),
                                                                      metaStream->getSize(),
                                                                      metaStream->getData(),
                                                                      metaStream->getMD(),
                                                                      agpTransCount);
                                

                                //  Search the address in the list of program uploads
                                ProgramUploadsIterator upIt = programUploads.find(metaStream->getAddress());
                                
                                //  Check if the upload was found
                                if (upIt != programUploads.end())
                                {
                                    //  Update data.
                                    (upIt->second)->updateData(lastProgramUpload->data, lastProgramUpload->size,
                                        lastProgramUpload->agpTransID);
                                }
                                else
                                {
                                    //  Insert the new program upload.
                                    programUploads.insert(make_pair(lastProgramUpload->address, lastProgramUpload)); 
                                }
                            }
                            
                            break;
                            
                        case META_STREAM_PRELOAD:
                        
                            //  Check if this upload operation may be a shader program upload.
                            if (metaStream->getSize() <= (SHADERINSTRUCTIONSIZE * MAXSHADERINSTRUCTIONS))
                            {
                                //delete lastProgramUpload;
                                
                                lastProgramUpload = new ProgramUpload(metaStream->getAddress(),
                                                                      metaStream->getSize(),
                                                                      metaStream->getData(),
                                                                      metaStream->getMD(),
                                                                      agpTransCount);
                                                                      
                                //  Search the address in the list of program uploads
                                ProgramUploadsIterator upIt = programUploads.find(metaStream->getAddress());
                                
                                //  Check if the upload was found
                                if (upIt != programUploads.end())
                                {
                                    //  Update data.
                                    (upIt->second)->updateData(lastProgramUpload->data, lastProgramUpload->size,
                                        lastProgramUpload->agpTransID);
                                }
                                else
                                {
                                    //  Insert the new program upload.
                                    programUploads.insert(make_pair(lastProgramUpload->address, lastProgramUpload)); 
                                }
                            }

                            break;
                            
                        case META_STREAM_COMMAND:
                        
                            //  Determine how to skip the MetaStream based on the MetaStream command.
                            switch(metaStream->getGPUCommand())
                            {
                                case GPU_DRAW:
                                
                                    //  Ignore all the GPU_DRAW transactions.
                                    delete metaStream;
                                    metaStream = NULL;
                                    
                                    break;
                                    
                                case GPU_SWAPBUFFERS:
                              
                                    cout << "Frame " << (traceFirstFrame + currentFrame) << " Skipped" << endl;
                                    
                                    //  Ignore the SWAPBUFFER command from a frame being skipped.
                                    delete metaStream;
                                    metaStream = NULL;
                                    
                                    //  Update frame counter.  
                                    currentFrame++;
                                    
                                    //  Check if all the frames were skipped.
                                    if (currentFrame == startFrame)
                                    {
                                        cout << "TraceDriverMeta::nxtMetaStream() -> Disabling preload..." << endl;
                                            
                                        //  Check if skipping commands has to end.
                                        if (startTransaction == 0)
                                        {
                                            //  Start loading the cached shader programs.
                                            currentPhase = TP_LOAD_SHADERS;
                                        }
                                    }
                                    
                                    
                                    break;

                                case GPU_LOAD_VERTEX_PROGRAM:
                                
                                    
                                    //  Check the address of the program load with the last upload address.
                                    if ((lastProgramUpload != NULL) && (lastProgramUpload->address == vertexProgramAddress))
                                    {
                                        //  Search the address in the list of program uploads
                                        ProgramUploadsIterator upIt = programUploads.find(vertexProgramAddress);
                                        
                                        //  Check if the upload was found
                                        if (upIt != programUploads.end())
                                        {
                                            //  Update data.
                                            //(upIt->second)->updateData(lastProgramUpload->data, lastProgramUpload->size,
                                            //    lastProgramUpload->agpTransID);
                                            
                                            //  Update the shader program cache.
                                            memcpy(&vertProgramCache[vertexProgramPC * SHADERINSTRUCTIONSIZE], lastProgramUpload->data, vertexProgramSize);
                                        }
                                        
                                        lastProgramUpload = NULL;
                                    }
                                    else
                                    {
                                        //  Search the upload address in the list of uploaded programas.
                                        
                                        //  Search the address in the list of program uploads
                                        ProgramUploadsIterator upIt = programUploads.find(vertexProgramAddress);
                                        
                                        //  Check if the upload was found
                                        if (upIt != programUploads.end())
                                        {
                                            if (upIt->second->size < vertexProgramSize)
                                            {
                                                printf("(Vertex) PC %x Address %x Size %d Upload Size %d\n", vertexProgramPC,
                                                    vertexProgramAddress, vertexProgramSize, upIt->second->size);
                                                CG_ASSERT("Upload program data smaller than required by load command.");
                                            }
                                            
                                            //  Update the shader program cache.
                                            memcpy(&vertProgramCache[vertexProgramPC * SHADERINSTRUCTIONSIZE], upIt->second->data, vertexProgramSize);
                                        }
                                        else
                                        {
                                            CG_ASSERT("Data for shader program load operations was not found.");
                                        }
                                        
                                    }
                                    
                                    //  Ignoring all commands;
                                    delete metaStream;
                                    metaStream = NULL;
                                    
                                    break;
                                
                                case GPU_LOAD_FRAGMENT_PROGRAM:
                                
                                    //  Check the address of the program load with the last upload address.
                                    if ((lastProgramUpload != NULL) && (lastProgramUpload->address == fragmentProgramAddress))
                                    {
                                        //  Search the address in the list of program uploads
                                        ProgramUploadsIterator upIt = programUploads.find(fragmentProgramAddress);
                                        
                                        //  Check if the upload was found
                                        if (upIt != programUploads.end())
                                        {
                                            //  Update data.
                                            //(upIt->second)->updateData(lastProgramUpload->data, lastProgramUpload->size,
                                            //    lastProgramUpload->agpTransID);
                                            
                                            //  Update the shader program cache.
                                            memcpy(&fragProgramCache[fragmentProgramPC * SHADERINSTRUCTIONSIZE], lastProgramUpload->data, fragmentProgramSize);
                                        }
                                    }
                                    else
                                    {
                                        //  Search the upload address in the list of uploaded programas.
                                        
                                        //  Search the address in the list of program uploads
                                        ProgramUploadsIterator upIt = programUploads.find(fragmentProgramAddress);
                                        
                                        //  Check if the upload was found
                                        if (upIt != programUploads.end())
                                        {
                                            if (upIt->second->size < fragmentProgramSize)
                                            {
                                                printf("(Fragment) PC %x Address %x Size %d Upload Size %d\n", fragmentProgramPC,
                                                    fragmentProgramAddress, fragmentProgramSize, upIt->second->size);
                                                CG_ASSERT("Upload program data smaller than required by load command.");
                                            }
                                            //  Update the shader program cache.
                                            memcpy(&fragProgramCache[fragmentProgramPC * SHADERINSTRUCTIONSIZE], upIt->second->data, fragmentProgramSize);
                                        }
                                        else
                                        {
                                            CG_ASSERT("Data for shader program load operations was not found.");
                                        }
                                        
                                    }
                                    
                                    //  Ignoring all commands;
                                    delete metaStream;
                                    metaStream = NULL;
                                    
                                    break;
                                    
                                case GPU_BLIT:
                                
                                    //  Ignore all the GPU_BLIT transactions.
                                    delete metaStream;
                                    metaStream = NULL;
                                    
                                    break;                                
                            }
                            
                            break;
                            
                        case META_STREAM_REG_WRITE:
                        
                            //  Update register cache with the register write.
                            registerCache.writeRegister(metaStream->getGPURegister(),
                                                        metaStream->getGPUSubRegister(),
                                                        metaStream->getGPURegData(),
                                                        metaStream->getMD());
                            
                            //  Check for shader program related registers.
                            switch(metaStream->getGPURegister())
                            {
                                case GPU_FRAGMENT_PROGRAM:
                                
                                    fragmentProgramAddress = metaStream->getGPURegData().uintVal;
                                    
                                    break;
                                    
                                case GPU_FRAGMENT_PROGRAM_PC:

                                    fragmentProgramPC = metaStream->getGPURegData().uintVal;
                                    
                                    break;
                                    
                                case GPU_FRAGMENT_PROGRAM_SIZE:
                                
                                    fragmentProgramSize = metaStream->getGPURegData().uintVal;
                                    
                                    break;

                                case GPU_VERTEX_PROGRAM:
                                
                                    vertexProgramAddress = metaStream->getGPURegData().uintVal;
                                    
                                    break;

                                case GPU_VERTEX_PROGRAM_PC:
                                
                                    vertexProgramPC = metaStream->getGPURegData().uintVal;
                                    
                                    break;
                                    
                                case GPU_VERTEX_PROGRAM_SIZE:
                                    
                                    vertexProgramSize = metaStream->getGPURegData().uintVal;
                                    
                                    break;

                                default:
                                    break;
                                 
                            }
                        
                            //  Ignore all the register writes for frames being skipped.
                            delete metaStream;
                            metaStream = NULL;
                            
                            break;
                            
                        case META_STREAM_EVENT:
                        
                            //  Ignore events in the initialization phase.
                            delete metaStream;
                            metaStream = NULL;
                            
                            break;
                            
                    }            
                    
                    break;
                    
                case TP_LOAD_SHADERS:
                    {
                        GPURegData data;
                        
                        switch(shaderProgramLoadPhase)
                        {
                            case 0:
                            
                                //  Upload the fragment shader cache into the GPU memory.
                                metaStream = new cgoMetaStream(0, sizeof(fragProgramCache), fragProgramCache, 0);
                                
                                break;
                                
                            case 1:
                                              
                                //  Set fragment program PC register.
                                data.uintVal = 0;
                                metaStream = new cgoMetaStream(GPU_FRAGMENT_PROGRAM_PC, 0, data, 0);
                                
                                break;    
                                
                            case 2:
                                              
                                //  Set fragment program Address register.
                                data.uintVal = 0;
                                metaStream = new cgoMetaStream(GPU_FRAGMENT_PROGRAM, 0, data, 0);
                                
                                break;    

                            case 3:
                                              
                                //  Set fragment program size register.
                                data.uintVal = sizeof(fragProgramCache);
                                metaStream = new cgoMetaStream(GPU_FRAGMENT_PROGRAM_SIZE, 0, data, 0);
                                
                                break;    

                            case 4:
                                
                                //  Load fragment programs.
                                metaStream = new cgoMetaStream(GPU_LOAD_FRAGMENT_PROGRAM);
                                
                                break;
                                
                            case 5:
                            
                                //  Upload the vertex shader cache into the GPU memory.
                                metaStream = new cgoMetaStream(0, sizeof(vertProgramCache), vertProgramCache, 0);
                                
                                break;
                                
                            case 6:
                                              
                                //  Set vertex program PC register.
                                data.uintVal = 0;
                                metaStream = new cgoMetaStream(GPU_VERTEX_PROGRAM_PC, 0, data, 0);
                                
                                break;    
                                
                            case 7:
                                              
                                //  Set vertex program Address register.
                                data.uintVal = 0;
                                metaStream = new cgoMetaStream(GPU_VERTEX_PROGRAM, 0, data, 0);
                                
                                break;    

                            case 8:
                                              
                                //  Set vertex program size register.
                                data.uintVal = sizeof(vertProgramCache);
                                metaStream = new cgoMetaStream(GPU_VERTEX_PROGRAM_SIZE, 0, data, 0);
                                
                                break;    

                            case 9:
                                
                                //  Load fragment programs.
                                metaStream = new cgoMetaStream(GPU_LOAD_VERTEX_PROGRAM);
                                
                                break;

                            case 10:
                            
                                //  Destroy program uploads list.
                                ProgramUploadsIterator it = programUploads.begin();
                                
                                while(it != programUploads.end())
                                {
                                    delete it->second;
                                    it++;
                                }
                                
                                programUploads.clear();
                                
                                //  Start to load the cached register writes into the simulator.
                                currentPhase = TP_LOAD_REGS;
                            
                                break;
                        }
                    
                        shaderProgramLoadPhase++;
                        
                    }
                    break;
                

                case TP_LOAD_REGS:
                    {
                        //  Send all the cached register writes to the GPU.
                        GPURegister gpuReg;
                        U32 index;
                        GPURegData data;
                        U32 md;
                        bool found;
                        
                        //  Retrieve the next register write from the buffer.
                        found = registerCache.flushNextRegister(gpuReg, index, data, md);
                        
                        //  Check if a register write was found in the buffer.
                        if (found)
                        {
                            //  Create a new MetaStream for writing the register into the GPU.
                            metaStream = new cgoMetaStream(gpuReg, index, data, md);
                        }
                        else
                        {
                            //  Start the clear z stencil buffer phase.
                            currentPhase = TP_CLEARZSTBUFFER;
                        }
                    }                    
                    break;

                case TP_CLEARZSTBUFFER:
                
                    metaStream = new cgoMetaStream(GPU_CLEARZSTENCILBUFFER);
                    
                    //  Start the clear color buffer phase.
                    currentPhase = TP_CLEARCOLORBUFFER;
                    
                    break;                
            
                case TP_CLEARCOLORBUFFER:

                    metaStream = new cgoMetaStream(GPU_CLEARCOLORBUFFER);
                    
                    //  Start the end of initialization phase.
                    currentPhase = TP_END_INIT;
                    
                    break;
                    
                case TP_END_INIT:
                
                    //  Send MetaStream marking the end of the initialization phase
                    metaStream = new cgoMetaStream();
                    
                    //  Start simulation phase.
                    currentPhase = TP_SIM_START_EVENT;
                    
                    break;
                    
                case TP_SIM_START_EVENT:
                
                    //  Reset the end of frame event register.
                    metaStream = new cgoMetaStream(GPU_END_OF_FRAME_EVENT, "");
                    
                    //  Start simulation phase.
                    currentPhase = TP_SIMULATION;
                    
                    break;                    
                    
                case TP_SIMULATION:
                                    
                    //  Check if the current transaction is an GPU_SWAPBUFFERS command.
                    if ((metaStream != NULL) && (metaStream->GetMetaStreamType() == META_STREAM_COMMAND) && (metaStream->getGPUCommand() == GPU_SWAPBUFFERS))
                    {
                        cout << "Dumping frame " << (traceFirstFrame + currentFrame) << endl;
                        currentFrame++;
                    }
                    
                    break;
            }
        }            
    }
    else
    {
        CG_ASSERT("No MetaStream trace file available.");
    }
    
    return metaStream;
}

//  Saves in a file the current frame position.
void TraceDriverMeta::saveTracePosition(fstream *f)
{
    f->write((char *) &currentFrame, sizeof(currentFrame));
    f->write((char *) &agpTransCount, sizeof(agpTransCount));
}

//  Loads from a file the start frame position.
void TraceDriverMeta::loadStartTracePosition(fstream *f)
{
    f->read((char *) &startFrame, sizeof(startFrame));
    f->read((char *) &startTransaction, sizeof(startTransaction));

    //  Check if the driver must skip frames.
    if ((startFrame != currentFrame) || (startTransaction > 0))
        currentPhase = TP_PREINIT;
}

//  Return the current position inside the trace file.
U32 TraceDriverMeta::getTracePosition()
{
    return agpTransCount;
}

